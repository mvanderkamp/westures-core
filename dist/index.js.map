{"version":3,"sources":["src/Gesture.js","src/Point2D.js","src/constants.js","src/PointerData.js","src/Input.js","src/State.js","src/utils.js","src/Region.js","src/Smoothable.js","index.js"],"names":["g_id","Gesture","type","element","handler","options","TypeError","id","DEFAULTS","state","count","active","length","event","enableKeys","disableKeys","minInputs","maxInputs","some","k","hook","data","centroid","phase","radius","target","Object","freeze","Number","MAX_VALUE","module","exports","Point2D","x","y","point","Math","atan2","points","totalDistanceTo","hypot","reduce","d","p","distanceTo","total","sum","pt","plus","CANCEL_EVENTS","KEYBOARD_EVENTS","MOUSE_EVENTS","POINTER_EVENTS","TOUCH_EVENTS","STATE_KEYS","STATE_KEY_STRINGS","CANCEL","END","MOVE","START","PHASE","pointercancel","touchcancel","mouseup","pointerup","touchend","mousemove","pointermove","touchmove","mousedown","pointerdown","touchstart","require","getEventObject","identifier","changedTouches","Array","from","find","touch","PointerData","source","originalEvent","time","Date","now","eventObj","pdata","angleTo","getPropagationPath","composedPath","path","node","document","parentNode","push","window","getElementsInPath","WeakSet","Input","currentData","initialElements","initial","current","previous","progress","has","symbols","inputs","Symbol","for","update_fns","TouchEvent","forEach","updateInput","PointerEvent","pointerId","MouseEvent","button","State","Map","activePoints","v","delete","filter","i","size","set","setPointerCapture","e","releasePointerCapture","get","update","console","warn","constructor","name","call","updateFields","values","getInputsNotInPhase","map","acc","cur","dist","setFilter","predicate","result","Set","add","setDifference","left","right","Region","settings","gestures","activeGestures","potentialGestures","capture","preventDefault","activate","eventNames","concat","arbitrate","bind","eventName","addEventListener","once","passive","cancel","handleKeyboardEvent","resetActiveGestures","indexOf","key","oldActiveGestures","setActiveGestures","gesture","evaluateHook","isEnabled","input","wasInitiallyInside","isInitial","setPotentialGestures","hasNoInputs","updateAllInputs","updateActiveGestures","clearEndedInputs","pruneActiveGestures","getGesturesByElement","g","removeGesture","cascade","smooth","smoothingIsApplicable","isRequested","matchMedia","matches","Smoothable","final_options","next","applySmoothing","identity","average","a","b"],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["/*\n * Contains the Gesture class\n */\n\n'use strict';\n\nlet g_id = 0;\n\n/**\n * The Gesture class that all gestures inherit from. A custom gesture class will\n * need to override some or all of the four phase \"hooks\": start, move, end, and\n * cancel.\n *\n * @memberof westures-core\n *\n * @param {string} type - The name of the gesture.\n * @param {Element} element - The element to which to associate the gesture.\n * @param {Function} handler - The function handler to execute when a gesture\n *    is recognized on the associated element.\n * @param {object} [options] - Generic gesture options\n * @param {westures-core.STATE_KEYS[]} [options.enableKeys=[]] - List of keys\n * which will enable the gesture. The gesture will not be recognized unless one\n * of these keys is pressed while the interaction occurs. If not specified or an\n * empty list, the gesture is treated as though the enable key is always down.\n * @param {westures-core.STATE_KEYS[]} [options.disableKeys=[]] - List of\n * keys whicyh will disable the gesture. The gesture will not be recognized if\n * one of these keys is pressed. If not specified or an empty list, the gesture\n * is treated as though the disable key is never down.\n * @param {number} [options.minInputs=1] - The minimum number of pointers that\n * must be active for the gesture to be recognized. Uses >=.\n * @param {number} [options.maxInputs=Number.MAX_VALUE] - The maximum number of\n * pointers that may be active for the gesture to be recognized. Uses <=.\n */\nclass Gesture {\n  constructor(type, element, handler, options = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('Gestures require a string type / name');\n    }\n\n    /**\n     * The name of the gesture. (e.g. 'pan' or 'tap' or 'pinch').\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * The unique identifier for each gesture. This allows for distinctions\n     * across instances of Gestures that are created on the fly (e.g.\n     * gesture-tap-1, gesture-tap-2).\n     *\n     * @type {string}\n     */\n    this.id = `gesture-${this.type}-${g_id++}`;\n\n    /**\n     * The element to which to associate the gesture.\n     *\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * The function handler to execute when the gesture is recognized on the\n     * associated element.\n     *\n     * @type {Function}\n     */\n    this.handler = handler;\n\n    /**\n     * The options settings.\n     *\n     * @type {object}\n     */\n    this.options = { ...Gesture.DEFAULTS, ...options };\n  }\n\n  /**\n   * Determines whether this gesture is enabled.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {boolean} true if enabled, false otherwise.\n   */\n  isEnabled(state) {\n    const count = state.active.length;\n    const event = state.event;\n    const { enableKeys, disableKeys, minInputs, maxInputs } = this.options;\n\n    return (minInputs <= count) && (maxInputs >= count) &&\n      (enableKeys.length === 0 || enableKeys.some(k => event[k])) &&\n      !disableKeys.some(k => event[k]);\n  }\n\n  /**\n   * Event hook for the start phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  start() {\n    return null;\n  }\n\n  /**\n   * Event hook for the move phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  move() {\n    return null;\n  }\n\n  /**\n   * Event hook for the end phase of a gesture.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  end() {\n    return null;\n  }\n\n  /**\n   * Event hook for when an input is cancelled.\n   *\n   * @param {State} state - The input state object of the current region.\n   *\n   * @return {?Object} Gesture is considered recognized if an Object is\n   *    returned.\n   */\n  cancel() {\n    return null;\n  }\n\n  /**\n   * Evalutes the given gesture hook, and dispatches any data that is produced.\n   *\n   * @private\n   *\n   * @param {string} hook - Must be one of 'start', 'move', 'end', or 'cancel'.\n   * @param {State} state - The current State instance.\n   */\n  evaluateHook(hook, state) {\n    const data = this[hook](state);\n    if (data) {\n      this.handler({\n        centroid: state.centroid,\n        event:    state.event,\n        phase:    hook,\n        radius:   state.radius,\n        type:     this.type,\n        target:   this.element,\n        ...data,\n      });\n    }\n  }\n}\n\nGesture.DEFAULTS = Object.freeze({\n  enableKeys:  [],\n  disableKeys: [],\n  minInputs:   1,\n  maxInputs:   Number.MAX_VALUE,\n});\n\nmodule.exports = Gesture;\n\n","/*\n * Contains the {@link Point2D} class.\n */\n\n'use strict';\n\n/**\n * The Point2D class stores and operates on 2-dimensional points, represented as\n * x and y coordinates.\n *\n * @memberof westures-core\n *\n * @param {number} [ x=0 ] - The x coordinate of the point.\n * @param {number} [ y=0 ] - The y coordinate of the point.\n */\nclass Point2D {\n  constructor(x = 0, y = 0) {\n    /**\n     * The x coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * The y coordinate of the point.\n     *\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Calculates the angle between this point and the given point.\n   *\n   * @param {!westures-core.Point2D} point - Projected point for calculating the\n   * angle.\n   *\n   * @return {number} Radians along the unit circle where the projected\n   * point lies.\n   */\n  angleTo(point) {\n    return Math.atan2(point.y - this.y, point.x - this.x);\n  }\n\n  /**\n   * Determine the average distance from this point to the provided array of\n   * points.\n   *\n   * @param {!westures-core.Point2D[]} points - the Point2D objects to calculate\n   *    the average distance to.\n   *\n   * @return {number} The average distance from this point to the provided\n   *    points.\n   */\n  averageDistanceTo(points) {\n    return this.totalDistanceTo(points) / points.length;\n  }\n\n  /**\n   * Clone this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, identical to this point.\n   */\n  clone() {\n    return new Point2D(this.x, this.y);\n  }\n\n  /**\n   * Calculates the distance between two points.\n   *\n   * @param {!westures-core.Point2D} point - Point to which the distance is\n   * calculated.\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(point) {\n    return Math.hypot(point.x - this.x, point.y - this.y);\n  }\n\n  /**\n   * Subtract the given point from this point.\n   *\n   * @param {!westures-core.Point2D} point - Point to subtract from this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the result of (this\n   * - point).\n   */\n  minus(point) {\n    return new Point2D(\n      this.x - point.x,\n      this.y - point.y\n    );\n  }\n\n  /**\n   * Return the summation of this point to the given point.\n   *\n   * @param {!westures-core.Point2D} point - Point to add to this point.\n   *\n   * @return {westures-core.Point2D} A new Point2D, which is the addition of the\n   * two points.\n   */\n  plus(point) {\n    return new Point2D(\n      this.x + point.x,\n      this.y + point.y,\n    );\n  }\n\n  /**\n   * Calculates the total distance from this point to an array of points.\n   *\n   * @param {!westures-core.Point2D[]} points - The array of Point2D objects to\n   *    calculate the total distance to.\n   *\n   * @return {number} The total distance from this point to the provided points.\n   */\n  totalDistanceTo(points) {\n    return points.reduce((d, p) => d + this.distanceTo(p), 0);\n  }\n\n  /**\n   * Calculates the centroid of a list of points.\n   *\n   * @param {westures-core.Point2D[]} points - The array of Point2D objects for\n   * which to calculate the centroid.\n   *\n   * @return {westures-core.Point2D} The centroid of the provided points.\n   */\n  static centroid(points = []) {\n    if (points.length === 0) return null;\n\n    const total = Point2D.sum(points);\n    return new Point2D(\n      total.x / points.length,\n      total.y / points.length,\n    );\n  }\n\n  /**\n   * Calculates the sum of the given points.\n   *\n   * @param {westures-core.Point2D[]} points - The Point2D objects to sum up.\n   *\n   * @return {westures-core.Point2D} A new Point2D representing the sum of the\n   * given points.\n   */\n  static sum(points = []) {\n    return points.reduce((total, pt) => total.plus(pt), new Point2D(0, 0));\n  }\n}\n\nmodule.exports = Point2D;\n\n","/*\n * Contains event list definitions, PHASE mapping, and other constants.\n */\n\n'use strict';\n\n/**\n * List of events that trigger the cancel phase.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst CANCEL_EVENTS = Object.freeze([\n  'blur',\n  'pointercancel',\n  'touchcancel',\n]);\n\n/**\n * List of keyboard events that trigger a restart.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst KEYBOARD_EVENTS = Object.freeze([\n  'keydown',\n  'keyup',\n]);\n\n/**\n * List of mouse events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst MOUSE_EVENTS = Object.freeze([\n  'mousedown',\n  'mousemove',\n  'mouseup',\n]);\n\n/**\n * List of pointer events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst POINTER_EVENTS = Object.freeze([\n  'pointerdown',\n  'pointermove',\n  'pointerup',\n]);\n\n/**\n * List of touch events to listen to.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst TOUCH_EVENTS = Object.freeze([\n  'touchend',\n  'touchmove',\n  'touchstart',\n]);\n\n/**\n * List of potentially state-modifying keys.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst STATE_KEYS = Object.freeze([\n  'altKey',\n  'ctrlKey',\n  'metaKey',\n  'shiftKey',\n]);\n\n/**\n * List of the 'key' values on KeyboardEvent objects of the potentially\n * state-modifying keys.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst STATE_KEY_STRINGS = Object.freeze([\n  'Alt',\n  'Control',\n  'Meta',\n  'Shift',\n]);\n\n/**\n * The cancel phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst CANCEL = 'cancel';\n\n/**\n * The end phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst END = 'end';\n\n/**\n * The move phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst MOVE = 'move';\n\n/**\n * The start phase.\n *\n * @private\n * @memberof westures-core\n * @type { string }\n */\nconst START = 'start';\n\n/**\n * Normalizes window events to be either of type start, move, end, or cancel.\n *\n * @private\n * @memberof westures-core\n * @enum {string}\n */\nconst PHASE = Object.freeze({\n  pointercancel: CANCEL,\n  touchcancel:   CANCEL,\n\n  mouseup:       END,\n  pointerup:     END,\n  touchend:      END,\n\n  mousemove:   MOVE,\n  pointermove: MOVE,\n  touchmove:   MOVE,\n\n  mousedown:   START,\n  pointerdown: START,\n  touchstart:  START,\n});\n\nmodule.exports = {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEYS,\n  STATE_KEY_STRINGS,\n\n  CANCEL,\n  END,\n  MOVE,\n  START,\n\n  PHASE,\n};\n\n","/*\n * Contains the {@link PointerData} class\n */\n\n'use strict';\n\nconst Point2D   = require('./Point2D.js');\nconst { PHASE } = require('./constants.js');\n\n/**\n * @private\n * @inner\n * @memberof PointerData\n *\n * @return {Event} The Event object which corresponds to the given identifier.\n *    Contains pageX, pageY values (or whichever X/Y source was selected).\n */\nfunction getEventObject(event, identifier) {\n  if (event.changedTouches) {\n    return Array.from(event.changedTouches).find(touch => {\n      return touch.identifier === identifier;\n    });\n  }\n  return event;\n}\n\n/**\n * Low-level storage of pointer data based on incoming data from an interaction\n * event.\n *\n * @param {Event} event - The event object being wrapped.\n * @param {number} identifier - The index of touch if applicable\n * @param {string} [source='page'] - One of 'page', 'client', or 'screen'.\n * Determines what the source of (x,y) coordinates will be from the input\n * events. ('X' and 'Y' will be appended, then those are the properties that\n * will be looked up).\n */\nclass PointerData {\n  constructor(event, identifier, source = 'page') {\n    /**\n     * The original event object.\n     *\n     * @type {Event}\n     */\n    this.originalEvent = event;\n\n    /**\n     * The type or 'phase' of this batch of pointer data. 'start' or 'move' or\n     * 'end' or 'cancel'\n     *\n     * @type {string}\n     */\n    this.type = PHASE[event.type];\n\n    /**\n     * The timestamp of the event in milliseconds elapsed since January 1, 1970,\n     * 00:00:00 UTC.\n     *\n     * @type {number}\n     */\n    this.time = Date.now();\n\n    const eventObj = getEventObject(event, identifier);\n    /**\n     * The (x,y) coordinate of the event, wrapped in a Point2D.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.point = new Point2D(eventObj[`${source}X`], eventObj[`${source}Y`]);\n    // this.point = new Point2D(eventObj.clientX, eventObj.clientY);\n  }\n\n  /**\n   * Calculates the angle between this event and the given event.\n   *\n   * @param {PointerData} pdata\n   *\n   * @return {number} Radians measurement between this event and the given\n   *    event's points.\n   */\n  angleTo(pdata) {\n    return this.point.angleTo(pdata.point);\n  }\n\n  /**\n   * Calculates the distance between two PointerDatas.\n   *\n   * @param {PointerData} pdata\n   *\n   * @return {number} The distance between the two points, a.k.a. the\n   *    hypoteneuse.\n   */\n  distanceTo(pdata) {\n    return this.point.distanceTo(pdata.point);\n  }\n}\n\nmodule.exports = PointerData;\n\n","/*\n * Contains the {@link Input} class\n */\n\n'use strict';\n\nconst PointerData = require('./PointerData.js');\n\n/**\n * In case event.composedPath() is not available.\n *\n * @private\n * @inner\n * @memberof Input\n *\n * @param {Event} event\n *\n * @return {Element[]} The elements along the composed path of the event.\n */\nfunction getPropagationPath(event) {\n  if (typeof event.composedPath === 'function') {\n    return event.composedPath();\n  }\n\n  const path = [];\n  for (let node = event.target; node !== document; node = node.parentNode) {\n    path.push(node);\n  }\n  path.push(document);\n  path.push(window);\n\n  return path;\n}\n\n/**\n * A WeakSet is used so that references will be garbage collected when the\n * element they point to is removed from the page.\n *\n * @private\n * @inner\n * @memberof Input\n * @return {WeakSet.<Element>} The Elements in the path of the given event.\n */\nfunction getElementsInPath(event) {\n  return new WeakSet(getPropagationPath(event));\n}\n\n/**\n * Tracks a single input and contains information about the current, previous,\n * and initial events. Contains the progress of each Input and its associated\n * gestures.\n *\n * @param {(PointerEvent | MouseEvent | TouchEvent)} event - The input event\n * which will initialize this Input object.\n * @param {number} identifier - The identifier for this input, so that it can\n * be located in subsequent Event objects.\n * @param {string} [source='page'] - One of 'page', 'client', or 'screen'.\n * Determines what the source of (x,y) coordinates will be from the input\n * events. ('X' and 'Y' will be appended, then those are the properties that\n * will be looked up).\n */\nclass Input {\n  constructor(event, identifier, source) {\n    const currentData = new PointerData(event, identifier, source);\n\n    /**\n     * Which X/Y attributes of input events to look up for determining input\n     * location.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = source;\n\n    /**\n     * The set of elements along the original event's propagation path at the\n     * time it was dispatched.\n     *\n     * @private\n     * @type {WeakSet.<Element>}\n     */\n    this.initialElements = getElementsInPath(event);\n\n    /**\n     * Holds the initial data from the mousedown / touchstart / pointerdown that\n     * began this input.\n     *\n     * @type {PointerData}\n     */\n    this.initial = currentData;\n\n    /**\n     * Holds the most current pointer data for this Input.\n     *\n     * @type {PointerData}\n     */\n    this.current = currentData;\n\n    /**\n     * Holds the previous pointer data for this Input.\n     *\n     * @type {PointerData}\n     */\n    this.previous = currentData;\n\n    /**\n     * The identifier for the pointer / touch / mouse button associated with\n     * this input.\n     *\n     * @type {number}\n     */\n    this.identifier = identifier;\n\n    /**\n     * Stores internal state between events for each gesture based off of the\n     * gesture's id.\n     *\n     * @private\n     * @type {Object}\n     */\n    this.progress = {};\n  }\n\n  /**\n   * The phase of the input: 'start' or 'move' or 'end' or 'cancel'\n   *\n   * @type {string}\n   */\n  get phase() { return this.current.type; }\n\n  /**\n   * The timestamp of the initiating event for this input.\n   *\n   * @type {number}\n   */\n  get startTime() { return this.initial.time; }\n\n  /**\n   * @private\n   *\n   * @param {string} id - The ID of the gesture whose progress is sought.\n   *\n   * @return {Object} The progress of the gesture.\n   */\n  getProgressOfGesture(id) {\n    if (!this.progress[id]) {\n      this.progress[id] = {};\n    }\n    return this.progress[id];\n  }\n\n  /**\n   * @return {number} The distance between the initiating event for this input\n   *    and its current event.\n   */\n  totalDistance() {\n    return this.initial.distanceTo(this.current);\n  }\n\n  /**\n   * Saves the given raw event in PointerData form as the current data for this\n   * input, pushing the old current data into the previous slot, and tossing\n   * out the old previous data.\n   *\n   * @private\n   *\n   * @param {Event} event - The event object to wrap with a PointerData.\n   */\n  update(event) {\n    this.previous = this.current;\n    this.current = new PointerData(event, this.identifier, this.source);\n  }\n\n  /**\n   * Determines if this PointerData was inside the given element at the time it\n   * was dispatched.\n   *\n   * @private\n   *\n   * @param {Element} element\n   *\n   * @return {boolean} true if the Input began inside the element, false\n   *    otherwise.\n   */\n  wasInitiallyInside(element) {\n    return this.initialElements.has(element);\n  }\n}\n\nmodule.exports = Input;\n\n","/*\n * Contains the {@link State} class\n */\n\n'use strict';\n\nconst {\n  CANCEL,\n  END,\n  MOVE,\n  PHASE,\n  START,\n} = require('./constants.js');\nconst Input     = require('./Input.js');\nconst Point2D   = require('./Point2D.js');\n\nconst symbols = Object.freeze({\n  inputs: Symbol.for('inputs'),\n});\n\n/**\n * Set of helper functions for updating inputs based on type of input.\n * Must be called with a bound 'this', via bind(), or call(), or apply().\n *\n * @private\n * @inner\n * @memberof State\n */\nconst update_fns = {\n  TouchEvent: function TouchEvent(event) {\n    Array.from(event.changedTouches).forEach(touch => {\n      this.updateInput(event, touch.identifier);\n    });\n  },\n\n  PointerEvent: function PointerEvent(event) {\n    this.updateInput(event, event.pointerId);\n  },\n\n  MouseEvent: function MouseEvent(event) {\n    if (event.button === 0) {\n      this.updateInput(event, event.button);\n    }\n  },\n};\n\n/**\n * Keeps track of currently active and ending input points on the interactive\n * surface.\n *\n * @param {Element} element - The element underpinning the associated Region.\n * @param {string} [source='page'] - One of 'page', 'client', or 'screen'.\n * Determines what the source of (x,y) coordinates will be from the input\n * events. ('X' and 'Y' will be appended, then those are the properties that\n * will be looked up).\n */\nclass State {\n  constructor(element, source) {\n    /**\n     * Keep a reference to the element for the associated region.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Which X/Y attributes of input events to look up for determining input\n     * location.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = source;\n\n    /**\n     * Keeps track of the current Input objects.\n     *\n     * @private\n     * @alias [@@inputs]\n     * @type {Map.<Input>}\n     * @memberof State\n     */\n    this[symbols.inputs] = new Map();\n\n    /**\n     * All currently valid inputs, including those that have ended.\n     *\n     * @type {Input[]}\n     */\n    this.inputs = [];\n\n    /**\n     * The array of currently active inputs, sourced from the current Input\n     * objects. \"Active\" is defined as not being in the 'end' phase.\n     *\n     * @type {Input[]}\n     */\n    this.active = [];\n\n    /**\n     * The array of latest point data for the currently active inputs, sourced\n     * from this.active.\n     *\n     * @type {westures-core.Point2D[]}\n     */\n    this.activePoints = [];\n\n    /**\n     * The centroid of the currently active points.\n     *\n     * @type {westures-core.Point2D}\n     */\n    this.centroid = {};\n\n    /**\n     * The latest event that the state processed.\n     *\n     * @type {Event}\n     */\n    this.event = null;\n  }\n\n  /**\n   * Deletes all inputs that are in the 'end' phase.\n   *\n   * @private\n   */\n  clearEndedInputs() {\n    this[symbols.inputs].forEach((v, k) => {\n      if (v.phase === 'end') this[symbols.inputs].delete(k);\n    });\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {Input[]} Inputs in the given phase.\n   */\n  getInputsInPhase(phase) {\n    return this.inputs.filter(i => i.phase === phase);\n  }\n\n  /**\n   * @param {string} phase - One of 'start', 'move', 'end', or 'cancel'.\n   *\n   * @return {Input[]} Inputs <b>not</b> in the given phase.\n   */\n  getInputsNotInPhase(phase) {\n    return this.inputs.filter(i => i.phase !== phase);\n  }\n\n  /**\n   * @private\n   * @return {boolean} True if there are no active inputs. False otherwise.\n   */\n  hasNoInputs() {\n    return this[symbols.inputs].size === 0;\n  }\n\n  /**\n   * Update the input with the given identifier using the given event.\n   *\n   * @private\n   *\n   * @param {Event} event - The event being captured.\n   * @param {number} identifier - The identifier of the input to update.\n   */\n  updateInput(event, identifier) {\n    switch (PHASE[event.type]) {\n    case START:\n      this[symbols.inputs].set(\n        identifier,\n        new Input(event, identifier, this.source)\n      );\n      try {\n        this.element.setPointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      break;\n    case END:\n      try {\n        this.element.releasePointerCapture(identifier);\n      } catch (e) {\n        // NOP: Optional operation failed.\n      }\n      // All of 'end', 'move', and 'cancel' perform updates, hence the\n      // following fall-throughs\n    case CANCEL:\n    case MOVE:\n      if (this[symbols.inputs].has(identifier)) {\n        this[symbols.inputs].get(identifier).update(event);\n      }\n      break;\n    default:\n      console.warn(`Unrecognized event type: ${event.type}`);\n    }\n  }\n\n  /**\n   * Updates the inputs with new information based upon a new event being fired.\n   *\n   * @private\n   * @param {Event} event - The event being captured.\n   */\n  updateAllInputs(event) {\n    update_fns[event.constructor.name].call(this, event);\n    this.updateFields(event);\n  }\n\n  /**\n   * Updates the convenience fields.\n   *\n   * @private\n   * @param {Event} event - Event with which to update the convenience fields.\n   */\n  updateFields(event) {\n    this.inputs = Array.from(this[symbols.inputs].values());\n    this.active = this.getInputsNotInPhase('end');\n    this.activePoints = this.active.map(i => i.current.point);\n    this.centroid = Point2D.centroid(this.activePoints);\n    // XXX: Delete this.radius for next released. It is not generally useful.\n    this.radius = this.activePoints.reduce((acc, cur) => {\n      const dist = cur.distanceTo(this.centroid);\n      return dist > acc ? dist : acc;\n    }, 0);\n    if (event) this.event = event;\n  }\n}\n\nmodule.exports = State;\n\n","/*\n * Contains various helpful utilities.\n */\n\n'use strict';\n\n/**\n * Performs a set filter operation.\n *\n * @private\n * @inner\n * @memberof westures-core.Region\n *\n * @param {Set} set - The set to filter.\n * @param {Function} predicate - Function to test elements of 'set'. Receives\n * one argument: the current set element.\n *\n * @return {Set} Set consisting of elements in 'set' for which 'predicate' is\n * true.\n */\nfunction setFilter(set, predicate) {\n  const result = new Set();\n  set.forEach(element => {\n    if (predicate(element)) {\n      result.add(element);\n    }\n  });\n  return result;\n}\n\n/**\n * Performs a set difference operation.\n *\n * @private\n * @inner\n * @memberof westures-core.Region\n *\n * @param {Set} left\n * @param {Set} right\n *\n * @return {Set} Set consisting of elements in 'left' that are not in\n * 'right'.\n */\nfunction setDifference(left, right) {\n  return setFilter(left, element => !right.has(element));\n}\n\nmodule.exports = Object.freeze({\n  setDifference,\n  setFilter,\n});\n\n","/*\n * Contains the Region class\n */\n\n'use strict';\n\nconst State = require('./State.js');\nconst {\n  CANCEL_EVENTS,\n  KEYBOARD_EVENTS,\n  MOUSE_EVENTS,\n  POINTER_EVENTS,\n  TOUCH_EVENTS,\n\n  STATE_KEY_STRINGS,\n\n  PHASE,\n\n  START,\n  END,\n} = require('./constants.js');\nconst {\n  setDifference,\n  setFilter,\n} = require('./utils.js');\n\n/**\n * Allows the user to specify the control region which will listen for user\n * input events.\n *\n * @memberof westures-core\n *\n * @param {Element} element - The element which should listen to input events.\n * @param {object} [options]\n * @param {boolean} [options.capture=false] - Whether the region uses the\n * capture phase of input events. If false, uses the bubbling phase.\n * @param {boolean} [options.preventDefault=true] - Whether the default\n * browser functionality should be disabled. This option should most likely be\n * ignored. Here there by dragons if set to false.\n * @param {string} [options.source='page'] - One of 'page', 'client', or\n * 'screen'. Determines what the source of (x,y) coordinates will be from the\n * input events. ('X' and 'Y' will be appended, then those are the properties\n * that will be looked up).\n */\nclass Region {\n  constructor(element, options = {}) {\n    const settings = { ...Region.DEFAULTS, ...options };\n\n    /**\n     * The list of relations between elements, their gestures, and the handlers.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.gestures = new Set();\n\n    /**\n     * The list of active gestures for the current input session.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.activeGestures = new Set();\n\n    /**\n     * The base list of potentially active gestures for the current input\n     * session.\n     *\n     * @private\n     * @type {Set.<Gesture>}\n     */\n    this.potentialGestures = new Set();\n\n    /**\n     * The element being bound to.\n     *\n     * @private\n     * @type {Element}\n     */\n    this.element = element;\n\n    /**\n     * Whether the region listens for captures or bubbles.\n     *\n     * @private\n     * @type {boolean}\n     */\n    this.capture = settings.capture;\n\n    /**\n     * Whether the default browser functionality should be disabled. This option\n     * should most likely be ignored. Here there by dragons if set to false.\n     *\n     * @private\n     * @type {boolean}\n     */\n    this.preventDefault = settings.preventDefault;\n\n    /**\n     * Which X/Y attribute of input events should be used for determining input\n     * locations.\n     *\n     * @private\n     * @type {string}\n     */\n    this.source = settings.source;\n\n    /**\n     * The internal state object for a Region.  Keeps track of inputs.\n     *\n     * @private\n     * @type {State}\n     */\n    this.state = new State(this.element, this.source);\n\n    // Begin operating immediately.\n    this.activate();\n  }\n\n  /**\n   * Activates the region by adding event listeners for all appropriate input\n   * events to the region's element.\n   *\n   * @private\n   */\n  activate() {\n    /*\n     * Having to listen to both mouse and touch events is annoying, but\n     * necessary due to conflicting standards and browser implementations.\n     * Pointer is a fallback for now instead of the primary, until I figure out\n     * all the details to do with pointer-events and touch-action and their\n     * cross browser compatibility.\n     *\n     * Listening to both mouse and touch comes with the difficulty that\n     * preventDefault() must be called to prevent both events from iterating\n     * through the system. However I have left it as an option to the end user,\n     * which defaults to calling preventDefault(), in case there's a use-case I\n     * haven't considered or am not aware of.\n     *\n     * It is also a good idea to keep regions small in large pages.\n     *\n     * See:\n     *  https://www.html5rocks.com/en/mobile/touchandmouse/\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Touch_events\n     *  https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events\n     */\n    let eventNames = [];\n    if (window.TouchEvent || window.MouseEvent) {\n      eventNames = MOUSE_EVENTS.concat(TOUCH_EVENTS);\n    } else {\n      eventNames = POINTER_EVENTS;\n    }\n\n    // Bind detected browser events to the region element.\n    const arbitrate = this.arbitrate.bind(this);\n    eventNames.forEach(eventName => {\n      this.element.addEventListener(eventName, arbitrate, {\n        capture: this.capture,\n        once:    false,\n        passive: false,\n      });\n    });\n\n    const cancel = this.cancel.bind(this);\n    CANCEL_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, cancel);\n    });\n\n    const handleKeyboardEvent = this.handleKeyboardEvent.bind(this);\n    KEYBOARD_EVENTS.forEach(eventName => {\n      window.addEventListener(eventName, handleKeyboardEvent);\n    });\n  }\n\n  /**\n   * Handles a cancel event. Resets the state and the active / potential gesture\n   * lists.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  cancel(event) {\n    event.preventDefault();\n    this.state = new State(this.element);\n    this.resetActiveGestures();\n  }\n\n  /**\n   * Handles a keyboard event, triggering a restart of any gestures that need\n   * it.\n   *\n   * @private\n   * @param {KeyboardEvent} event - The keyboard event.\n   */\n  handleKeyboardEvent(event) {\n    if (STATE_KEY_STRINGS.indexOf(event.key) >= 0) {\n      this.state.event = event;\n      const oldActiveGestures = this.activeGestures;\n      this.setActiveGestures();\n\n      setDifference(oldActiveGestures, this.activeGestures).forEach(gesture => {\n        gesture.evaluateHook(END, this.state);\n      });\n      setDifference(this.activeGestures, oldActiveGestures).forEach(gesture => {\n        gesture.evaluateHook(START, this.state);\n      });\n    }\n  }\n\n  /**\n   * Resets the active gestures.\n   *\n   * @private\n   */\n  resetActiveGestures() {\n    this.potentialGestures = new Set();\n    this.activeGestures = new Set();\n  }\n\n  /**\n   * Selects active gestures from the list of potentially active gestures.\n   *\n   * @private\n   */\n  setActiveGestures() {\n    this.activeGestures = setFilter(this.potentialGestures, gesture => {\n      return gesture.isEnabled(this.state);\n    });\n  }\n\n  /**\n   * Selects the potentially active gestures.\n   *\n   * @private\n   */\n  setPotentialGestures() {\n    const input = this.state.inputs[0];\n    this.potentialGestures = setFilter(this.gestures, gesture => {\n      return input.wasInitiallyInside(gesture.element);\n    });\n  }\n\n  /**\n   * Selects the gestures that are active for the current input sequence.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   * @param {boolean} isInitial - Whether this is an initial contact.\n   */\n  updateActiveGestures(event, isInitial) {\n    if (PHASE[event.type] === START) {\n      if (isInitial) {\n        this.setPotentialGestures();\n      }\n      this.setActiveGestures();\n    }\n  }\n\n  /**\n   * Evaluates whether the current input session has completed.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  pruneActiveGestures(event) {\n    if (PHASE[event.type] === END) {\n      if (this.state.hasNoInputs()) {\n        this.resetActiveGestures();\n      } else {\n        this.setActiveGestures();\n      }\n    }\n  }\n\n  /**\n   * All input events flow through this function. It makes sure that the input\n   * state is maintained, determines which gestures to analyze based on the\n   * initial position of the inputs, calls the relevant gesture hooks, and\n   * dispatches gesture data.\n   *\n   * @private\n   * @param {Event} event - The event emitted from the window object.\n   */\n  arbitrate(event) {\n    const isInitial = this.state.hasNoInputs();\n    this.state.updateAllInputs(event);\n    this.updateActiveGestures(event, isInitial);\n\n    if (this.activeGestures.size > 0) {\n      if (this.preventDefault) event.preventDefault();\n\n      this.activeGestures.forEach(gesture => {\n        gesture.evaluateHook(PHASE[event.type], this.state);\n      });\n    }\n\n    this.state.clearEndedInputs();\n    this.pruneActiveGestures(event);\n  }\n\n  /**\n   * Adds the given gesture to the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  addGesture(gesture) {\n    this.gestures.add(gesture);\n  }\n\n  /**\n   * Removes the given gesture from the region.\n   *\n   * @param {westures-core.Gesture} gesture - Instantiated gesture to add.\n   */\n  removeGesture(gesture) {\n    this.gestures.delete(gesture);\n    this.potentialGestures.delete(gesture);\n    this.activeGestures.delete(gesture);\n  }\n\n  /**\n   * Retrieves Gestures by their associated element.\n   *\n   * @private\n   *\n   * @param {Element} element - The element for which to find gestures.\n   *\n   * @return {Gesture[]} Gestures to which the element is bound.\n   */\n  getGesturesByElement(element) {\n    return setFilter(this.gestures, gesture => gesture.element === element);\n  }\n\n  /**\n   * Remove all gestures bound to the given element.\n   *\n   * @param {Element} element - The element to unbind.\n   */\n  removeGesturesByElement(element) {\n    this.getGesturesByElement(element).forEach(g => this.removeGesture(g));\n  }\n}\n\nRegion.DEFAULTS = Object.freeze({\n  capture:        false,\n  preventDefault: true,\n  source:         'page',\n});\n\nmodule.exports = Region;\n\n","/*\n * Contains the abstract Pinch class.\n */\n\n'use strict';\n\nconst cascade = Symbol('cascade');\nconst smooth = Symbol('smooth');\n\n/**\n * Determines whether to apply smoothing. Smoothing is on by default but turned\n * off if either:<br>\n *  1. The user explicitly requests that it be turned off.<br>\n *  2. The active pointer is not \"coarse\".<br>\n *\n * @see {@link\n * https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia}\n *\n * @inner\n * @memberof westures-core.Smoothable\n *\n * @param {boolean} isRequested - Whether smoothing was requested by the user.\n *\n * @returns {boolean} Whether to apply smoothing.\n */\nfunction smoothingIsApplicable(isRequested) {\n  if (isRequested) {\n    try {\n      return window.matchMedia('(pointer: coarse)').matches;\n    } catch (e) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A Smoothable datatype is one that is capable of smoothing out a series of\n * values as they come in, one at a time, providing a more consistent series. It\n * does this by creating some inertia in the values using a cascading average.\n * (For those who are interested in such things, this effectively means that it\n * provides a practical application of Zeno's Dichotomy).\n *\n * @example\n * const x = new Smoothable({ identity: 1 });\n * const a = x.next(1);   // 1.0\n * const b = x.next(1.2); // 1.1\n * const c = x.next(0.9); // 1.0\n * const d = x.next(0.6); // 0.8\n * const e = x.next(1.2); // 1.0\n * const f = x.next(1.6); // 1.3\n * x.restart();\n * const g = x.next(0);   // 0.5\n *\n * @memberof westures-core\n *\n * @param {Object} [options]\n * @param {boolean} [options.applySmoothing=true] Whether to apply smoothing to\n * the data.\n * @param {*} [options.identity=0] The identity value of this smoothable data.\n */\nclass Smoothable {\n  constructor(options = {}) {\n    const final_options = { ...Smoothable.DEFAULTS, ...options };\n\n    /**\n     * The function through which smoothed emits are passed.\n     *\n     * @method\n     * @param {*} data - The data to emit.\n     *\n     * @return {*} The smoothed out data.\n     */\n    this.next = null;\n    if (smoothingIsApplicable(final_options.applySmoothing)) {\n      this.next = this[smooth].bind(this);\n    } else {\n      this.next = data => data;\n    }\n\n    /**\n     * The \"identity\" value of the data that will be smoothed.\n     *\n     * @type {*}\n     * @default 0\n     */\n    this.identity = final_options.identity;\n\n    /**\n     * The cascading average of outgoing values.\n     *\n     * @memberof westures-core.Smoothable\n     * @alias [@@cascade]\n     * @type {object}\n     */\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Restart the Smoothable gesture.\n   */\n  restart() {\n    this[cascade] = this.identity;\n  }\n\n  /**\n   * Smooth out the outgoing data.\n   *\n   * @memberof westures-core.Smoothable\n   * @alias [@@smooth]\n   * @param {object} data - The next batch of data to emit.\n   *\n   * @return {?object}\n   */\n  [smooth](data) {\n    const average = this.average(this[cascade], data);\n    this[cascade] = average;\n    return average;\n  }\n\n  /**\n   * Average out two values, as part of the smoothing algorithm. Override this\n   * method if the data being smoothed is not a Number.\n   *\n   * @param {number} a\n   * @param {number} b\n   *\n   * @return {number} The average of 'a' and 'b'\n   */\n  average(a, b) {\n    return (a + b) / 2;\n  }\n}\n\nSmoothable.DEFAULTS = Object.freeze({\n  applySmoothing: true,\n  identity:       0,\n});\n\nmodule.exports = Smoothable;\n\n","/**\n * The global API interface for Westures. Exposes a constructor for the Region\n * and the generic Gesture class for user gestures to implement, as well as the\n * Point2D class, which may be useful.\n *\n * @namespace westures-core\n */\n\n'use strict';\n\nconst Gesture = require('./src/Gesture.js');\nconst Point2D = require('./src/Point2D.js');\nconst Region = require('./src/Region.js');\nconst Smoothable = require('./src/Smoothable.js');\n\nmodule.exports = {\n  Gesture,\n  Point2D,\n  Region,\n  Smoothable,\n};\n\n"]}